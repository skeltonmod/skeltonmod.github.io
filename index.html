<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GOOBbERNET</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
        }
        #container {
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
    <div id="container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, sphere;
        let audioContext, analyser, dataArray, bufferLength;
        let audio, audioSource;
        let isPlaying = false;
        let originalPositions = [];
        let composer, ditherPass;

        const audioUrl = 'https://files.catbox.moe/frm93q.mp3';
        const DitherShader = {
            uniforms: {
                'tDiffuse': { value: null },
                'resolution': { value: new THREE.Vector2() }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform vec2 resolution;
                varying vec2 vUv;

                // Bayer matrix for ordered dithering
                float bayer2(vec2 pos) {
                    return mod(pos.x + pos.y * 2.0, 4.0);
                }

                float bayer4(vec2 pos) {
                    vec2 p = mod(pos, 4.0);
                    return (bayer2(floor(p * 0.5)) * 4.0 + bayer2(p)) / 16.0;
                }

                float bayer8(vec2 pos) {
                    vec2 p = mod(pos, 8.0);
                    return (bayer4(floor(p * 0.5)) * 4.0 + bayer2(p)) / 64.0;
                }

                void main() {
                    vec4 color = texture2D(tDiffuse, vUv);
                    vec2 pixelPos = vUv * resolution;
                    
                    // Stronger dithering with increased range
                    float dither = (bayer8(pixelPos) - 0.5) * 1.5;
                    
                    // Reduce color depth more aggressively (fewer levels = stronger effect)
                    float levels = 4.0;
                    vec3 dithered;
                    dithered.r = floor(color.r * levels + dither) / levels;
                    dithered.g = floor(color.g * levels + dither) / levels;
                    dithered.b = floor(color.b * levels + dither) / levels;
                    
                    gl_FragColor = vec4(dithered, 1.0);
                }
            `
        };

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 10, 50);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 15;
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000);
            document.getElementById('container').appendChild(renderer.domElement);

            const geometry = new THREE.SphereGeometry(5, 64, 64);
            const material = new THREE.MeshPhongMaterial({
                color: 0x00ff88,
                wireframe: false,
                emissive: 0x002211,
                shininess: 100
            });
            sphere = new THREE.Mesh(geometry, material);
            scene.add(sphere);
            const positions = geometry.attributes.position;
            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const y = positions.getY(i);
                const z = positions.getZ(i);
                
                const length = Math.sqrt(x * x + y * y + z * z);
                originalPositions.push({
                    x: x,
                    y: y,
                    z: z,
                    nx: x / length,
                    ny: y / length,
                    nz: z / length
                });
            }

            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0xffffff, 1, 100);
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);

            const pointLight2 = new THREE.PointLight(0x00ffff, 0.5, 100);
            pointLight2.position.set(-10, -10, 10);
            scene.add(pointLight2);

            setupPostProcessing();

            window.addEventListener('resize', onWindowResize);

            setupAndPlayAudio();

            animate();
        }

        function setupPostProcessing() {
            // Create render target
            const renderTarget = new THREE.WebGLRenderTarget(
                window.innerWidth,
                window.innerHeight,
                {
                    minFilter: THREE.LinearFilter,
                    magFilter: THREE.LinearFilter,
                    format: THREE.RGBAFormat
                }
            );
            const ditherMaterial = new THREE.ShaderMaterial({
                uniforms: THREE.UniformsUtils.clone(DitherShader.uniforms),
                vertexShader: DitherShader.vertexShader,
                fragmentShader: DitherShader.fragmentShader
            });
            ditherMaterial.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);

            // Create scene for post-processing
            const postScene = new THREE.Scene();
            const postCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
            const postQuad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), ditherMaterial);
            postScene.add(postQuad);

            // Store for later use
            composer = {
                renderTarget: renderTarget,
                postScene: postScene,
                postCamera: postCamera,
                ditherMaterial: ditherMaterial
            };
        }

        async function setupAndPlayAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                bufferLength = analyser.frequencyBinCount;
                dataArray = new Uint8Array(bufferLength);

                audio = new Audio(audioUrl);
                audio.crossOrigin = "anonymous";
                audio.loop = true;
                audioSource = audioContext.createMediaElementSource(audio);
                audioSource.connect(analyser);
                analyser.connect(audioContext.destination);

                await new Promise((resolve, reject) => {
                    audio.addEventListener('canplaythrough', resolve, { once: true });
                    audio.addEventListener('error', reject, { once: true });
                    audio.load();
                });

                // Autoplay
                await audio.play();
                isPlaying = true;
                
            } catch (e) {
                console.error('Audio setup failed:', e);
                isPlaying = false;
            }
        }

        function updateSphere() {
            if (!analyser) return;

            analyser.getByteFrequencyData(dataArray);

            const positions = sphere.geometry.attributes.position;
            
            for (let i = 0; i < positions.count; i++) {
                const original = originalPositions[i];
                
                const freqIndex = Math.floor((i / positions.count) * bufferLength);
                const amplitude = dataArray[freqIndex] / 255.0;
                
                const spikeLength = amplitude * 3.0;
                
                const newX = original.x + original.nx * spikeLength;
                const newY = original.y + original.ny * spikeLength;
                const newZ = original.z + original.nz * spikeLength;
                
                positions.setXYZ(i, newX, newY, newZ);
            }
            
            positions.needsUpdate = true;
            sphere.geometry.computeVertexNormals();
            const avg = dataArray.reduce((a, b) => a + b) / bufferLength;
            const hue = (avg / 255) * 0.3;
            sphere.material.color.setHSL(hue + 0.4, 1, 0.5);
        }

        function animate() {
            requestAnimationFrame(animate);

            if (isPlaying) {
                updateSphere();
            }

            sphere.rotation.y += 0.005;
            sphere.rotation.x += 0.002;

            renderer.setRenderTarget(composer.renderTarget);
            renderer.render(scene, camera);

            composer.ditherMaterial.uniforms.tDiffuse.value = composer.renderTarget.texture;
            renderer.setRenderTarget(null);
            renderer.render(composer.postScene, composer.postCamera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            composer.renderTarget.setSize(window.innerWidth, window.innerHeight);
            composer.ditherMaterial.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>
