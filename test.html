<!DOCTYPE html>
<html>
  <head>
    <title>Dungeon Test</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser-ce/2.19.2/phaser.min.js"></script>
    <style>
      body {
        margin: 0;
        padding: 20px;
        display: flex;
        justify-content: center;
        background: #333;
      }
      #game-container {
        background: #000;
      }
    </style>
  </head>
  <body>
    <div id="game-container"></div>
    <script>
      // Entity base class
      class Entity extends Phaser.Sprite {
        constructor(game, x, y, color, size) {
          const bmd = game.add.bitmapData(size * 2, size * 2);
          const context = bmd.context;
          super(game, x * TILE_SIZE, y * TILE_SIZE, bmd);

          this.size = size;

          context.beginPath();
          if (this.drawCustomShape) {
            this.drawCustomShape(context, size, size);
          } else {
            context.arc(size, size, size / 2, 0, Math.PI * 2);
          }
          context.fillStyle = `#${color.toString(16).padStart(6, "0")}`;
          context.fill();

          this.anchor.setTo(0.5, 0.5);

          game.physics.arcade.enable(this);
          this.body.collideWorldBounds = true;

          this.z = y * LEVEL_WIDTH * 10 + 1;

          // Add to the main group for depth sorting
          gameGroup.add(this);
        }

        update() {
          super.update();
          // Update z property for depth sorting
          this.z = (this.y / TILE_SIZE) * LEVEL_WIDTH * 10 + 1;
        }
      }

      class Player extends Entity {
        constructor(game, x, y) {
          super(
            game,
            x,
            y,
            ENTITY_CONFIG.PLAYER_COLOR,
            ENTITY_CONFIG.ENTITY_SIZE
          );
          this.speed = 150;
        }

        update() {
          this.body.velocity.x = 0;
          this.body.velocity.y = 0;

          if (cursors.left.isDown) this.body.velocity.x = -this.speed;
          if (cursors.right.isDown) this.body.velocity.x = this.speed;
          if (cursors.up.isDown) this.body.velocity.y = -this.speed;
          if (cursors.down.isDown) this.body.velocity.y = this.speed;

          if (this.body.velocity.x !== 0 && this.body.velocity.y !== 0) {
            const factor = Math.sqrt(0.5);
            this.body.velocity.x *= factor;
            this.body.velocity.y *= factor;
          }

          this.z = this.y;
        }
      }

      class Enemy extends Entity {
        constructor(game, x, y) {
          super(
            game,
            x,
            y,
            ENTITY_CONFIG.ENEMY_COLOR,
            ENTITY_CONFIG.ENTITY_SIZE
          );
          this.body.immovable = true;
        }

        drawCustomShape(context, x, y) {
          const halfSize = this.size / 2;
          context.rect(x - halfSize, y - halfSize, this.size, this.size);
        }
      }

      class Chest extends Entity {
        constructor(game, x, y) {
          super(
            game,
            x,
            y,
            ENTITY_CONFIG.CHEST_COLOR,
            ENTITY_CONFIG.ENTITY_SIZE
          );
          this.body.immovable = true;
        }

        drawCustomShape(context, x, y) {
          const halfSize = this.size / 2;
          const quarterSize = this.size / 4;
          context.moveTo(x - halfSize, y + halfSize);
          context.lineTo(x + halfSize, y + halfSize);
          context.lineTo(x + halfSize, y - quarterSize);
          context.lineTo(x, y - halfSize);
          context.lineTo(x - halfSize, y - quarterSize);
          context.closePath();
        }
      }

      class Wall extends Phaser.Sprite {
        constructor(game, x, y) {
          const bmd = game.add.bitmapData(TILE_SIZE, TILE_SIZE);
          const context = bmd.context;

          super(game, x * TILE_SIZE, y * TILE_SIZE, bmd);

          context.fillStyle = `#${COLORS.WALL.toString(16).padStart(6, "0")}`;
          context.fillRect(0, 0, TILE_SIZE, TILE_SIZE);

          game.physics.arcade.enable(this);
          this.body.immovable = true;
          this.body.moves = false;

          if (!isWall(x, y - 1)) {
            // Adjust collision box for northern walls
            this.body.height = TILE_SIZE / 2;
            this.body.offset.y = TILE_SIZE / 2; // Offset to keep collision at bottom half
          }

          // Walls get a higher z-index base
          this.z = y * LEVEL_WIDTH * 10 + 2;

          gameGroup.add(this);
        }
      }

      const config = {
        width: 320,
        height: 240,
        renderer: Phaser.AUTO,
        parent: "game-container",
        state: {
          create: create,
          preload: preload,
          update: update,
          //   render: render,
        },
        physics: {
          default: "arcade",
          arcade: {
            debug: true,
          },
        },
      };

      const game = new Phaser.Game(config);

      const TILE_SIZE = 16;
      const LEVEL_WIDTH = 20;
      const LEVEL_HEIGHT = 15;

      const ENTITY_CONFIG = {
        NUM_ENEMIES: 5,
        NUM_CHESTS: 3,
        ENEMY_COLOR: 0xff0000,
        PLAYER_COLOR: 0x00ff00,
        CHEST_COLOR: 0xffd700,
        ENTITY_SIZE: 8,
      };

      const COLORS = {
        FLOOR: 0x444444,
        WALL: 0x666666,
        WALL_SHADOW: 0x222222,
        FLOOR_SHADOW: 0x333333,
      };

      let backgroundGraphics; // New graphics layer for floor and shadows
      let graphics; // Existing graphics layer for other elements
      let rooms = [];
      let pos2roomidx = {};
      let entities = [];
      let wallSprites;
      let wallTiles = new Set();
      let cursors;
      let player;
      let gameGroup; // Single group for all game objects

      function makeRoom(x, y, angle, ttl) {
        if (ttl < 0) return;

        if (Math.random() > 0.5) {
          const width = 3 + Math.floor(Math.random() * 4);
          const height = 3 + Math.floor(Math.random() * 4);

          const room = {
            x: Math.floor(x - width / 2),
            y: Math.floor(y - height / 2),
            w: width,
            h: height,
          };

          const dugRoom = dig(room, rooms.length + 1);
          if (dugRoom) {
            rooms.push(dugRoom);
          }
        }

        const numPaths = 1 + Math.floor(Math.random() * 2);
        const angles = [-0.25, 0, 0.25];
        const angleOffset = Math.floor(Math.random() * 3);

        for (let i = 0; i < numPaths; i++) {
          const newAngle = angle + angles[(angleOffset + i) % angles.length];
          makePath(x, y, newAngle, ttl - 1);
        }
      }

      function makePath(x, y, angle, ttl) {
        const length = 2 + Math.floor(Math.random() * 3);
        const width = 1 + Math.floor(Math.random() * 2);

        const direction = rotate(angle, { x: 1, y: 0 });

        const corridor = {
          x: Math.floor(x),
          y: Math.floor(y),
          w: direction.x !== 0 ? length : width,
          h: direction.y !== 0 ? length : width,
        };

        const dugCorridor = dig(corridor);

        if (dugCorridor) {
          const newX = x + direction.x * dugCorridor.w;
          const newY = y + direction.y * dugCorridor.h;
          makeRoom(newX, newY, angle, ttl - 1);
        }
      }

      function rotate(angle, point) {
        const cos = Math.cos(angle * Math.PI * 2);
        const sin = Math.sin(angle * Math.PI * 2);
        return {
          x: Math.round(point.x * cos - point.y * sin),
          y: Math.round(point.x * sin + point.y * cos),
        };
      }

      function dig(room, idx) {
        const x0 = Math.max(1, Math.floor(room.x));
        const y0 = Math.max(1, Math.floor(room.y));
        const x1 = Math.min(Math.floor(room.x + room.w), LEVEL_WIDTH - 2);
        const y1 = Math.min(Math.floor(room.y + room.h), LEVEL_HEIGHT - 2);

        const width = x1 - x0;
        const height = y1 - y0;

        if (width > 0 && height > 0) {
          for (let i = x0; i <= x1; i++) {
            for (let j = y0; j <= y1; j++) {
              const key = i + j * LEVEL_WIDTH;
              if (!pos2roomidx[key]) {
                pos2roomidx[key] = idx || -1;
              }
            }
          }
          return { x: x0, y: y0, w: width, h: height };
        }
        return null;
      }

      function getValidPosition(room) {
        let attempts = 0;
        const maxAttempts = 50;

        while (attempts < maxAttempts) {
          const x = room.x + Math.floor(Math.random() * room.w);
          const y = room.y + Math.floor(Math.random() * room.h);

          // Check if position is valid (not on a wall or too close to walls)
          let isValid = true;

          // Check the position and surrounding tiles
          for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
              const checkX = x + dx;
              const checkY = y + dy;
              if (isWall(checkX, checkY)) {
                isValid = false;
                break;
              }
            }
            if (!isValid) break;
          }

          if (isValid) {
            return { x, y };
          }

          attempts++;
        }

        return null;
      }

      function findWallTiles() {
        wallTiles.clear();
        for (let x = 0; x < LEVEL_WIDTH; x++) {
          for (let y = 0; y < LEVEL_HEIGHT; y++) {
            const key = x + y * LEVEL_WIDTH;
            if (pos2roomidx[key]) {
              for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                  if (dx === 0 && dy === 0) continue;
                  const nx = x + dx;
                  const ny = y + dy;
                  const nkey = nx + ny * LEVEL_WIDTH;
                  if (
                    !pos2roomidx[nkey] &&
                    nx >= 0 &&
                    nx < LEVEL_WIDTH &&
                    ny >= 0 &&
                    ny < LEVEL_HEIGHT
                  ) {
                    wallTiles.add(`${nx},${ny}`);
                  }
                }
              }
            }
          }
        }
      }

      function isWall(x, y) {
        return wallTiles.has(`${x},${y}`);
      }

      function preload() {
        cursors = game.input.keyboard.createCursorKeys();
      }

      function create() {
        game.physics.startSystem(Phaser.Physics.ARCADE);

        // Create background layer first (will render below everything)
        backgroundGraphics = game.add.graphics(0, 0);

        // Create main group for all game objects
        gameGroup = game.add.group();

        // Create regular graphics layer last (will render above everything)
        graphics = game.add.graphics(0, 0);
        graphics.fixedToCamera = true;

        generateLevel();
        game.input.onDown.add(generateLevel, this);
      }

      function update() {
        // Sort all game objects by y position
        gameGroup.sort("z", Phaser.Group.SORT_DESCENDING);

        // Handle collisions between all physics objects in the game group
        game.physics.arcade.collide(player, gameGroup);
      }

      function render() {
        // Draw the floor and shadows first
        graphics.clear();

        // Draw floor shadows
        graphics.beginFill(COLORS.FLOOR_SHADOW);
        for (let x = 0; x < LEVEL_WIDTH; x++) {
          for (let y = 0; y < LEVEL_HEIGHT; y++) {
            const key = x + y * LEVEL_WIDTH;
            if (pos2roomidx[key]) {
              graphics.drawRect(
                x * TILE_SIZE + 2,
                y * TILE_SIZE + 2,
                TILE_SIZE,
                TILE_SIZE
              );
            }
          }
        }
        graphics.endFill();

        // Draw floors
        graphics.beginFill(COLORS.FLOOR);
        for (let x = 0; x < LEVEL_WIDTH; x++) {
          for (let y = 0; y < LEVEL_HEIGHT; y++) {
            const key = x + y * LEVEL_WIDTH;
            if (pos2roomidx[key]) {
              graphics.drawRect(
                x * TILE_SIZE,
                y * TILE_SIZE,
                TILE_SIZE,
                TILE_SIZE
              );
            }
          }
        }
        graphics.endFill();

        // Draw wall shadows
        graphics.beginFill(COLORS.WALL_SHADOW);
        for (let x = 0; x < LEVEL_WIDTH; x++) {
          for (let y = 0; y < LEVEL_HEIGHT; y++) {
            if (isWall(x, y) && !isWall(x, y + 1)) {
              graphics.drawRect(
                x * TILE_SIZE,
                (y + 1) * TILE_SIZE,
                TILE_SIZE,
                TILE_SIZE / 2
              );
            }
          }
        }
        graphics.endFill();
      }

      function renderBackground() {
        backgroundGraphics.clear();

        // Draw floor shadows
        backgroundGraphics.beginFill(COLORS.FLOOR_SHADOW);
        for (let x = 0; x < LEVEL_WIDTH; x++) {
          for (let y = 0; y < LEVEL_HEIGHT; y++) {
            const key = x + y * LEVEL_WIDTH;
            if (pos2roomidx[key]) {
              backgroundGraphics.drawRect(
                x * TILE_SIZE + 2,
                y * TILE_SIZE + 2,
                TILE_SIZE,
                TILE_SIZE
              );
            }
          }
        }
        backgroundGraphics.endFill();

        // Draw floors
        backgroundGraphics.beginFill(COLORS.FLOOR);
        for (let x = 0; x < LEVEL_WIDTH; x++) {
          for (let y = 0; y < LEVEL_HEIGHT; y++) {
            const key = x + y * LEVEL_WIDTH;
            if (pos2roomidx[key]) {
              backgroundGraphics.drawRect(
                x * TILE_SIZE,
                y * TILE_SIZE,
                TILE_SIZE,
                TILE_SIZE
              );
            }
          }
        }
        backgroundGraphics.endFill();

        // Draw wall shadows
        backgroundGraphics.beginFill(COLORS.WALL_SHADOW);
        for (let x = 0; x < LEVEL_WIDTH; x++) {
          for (let y = 0; y < LEVEL_HEIGHT; y++) {
            if (isWall(x, y) && !isWall(x, y + 1)) {
              backgroundGraphics.drawRect(
                x * TILE_SIZE,
                (y + 1) * TILE_SIZE,
                TILE_SIZE,
                TILE_SIZE / 2
              );
            }
          }
        }
        backgroundGraphics.endFill();
      }

      function createWall(x, y) {
        return new Wall(game, x, y);
      }

      function generateLevel() {
        // Clear existing game objects
        gameGroup.removeAll(true);

        // Reset level data
        rooms = [];
        pos2roomidx = {};
        wallTiles.clear();

        const centerX = Math.floor(LEVEL_WIDTH / 2);
        const centerY = Math.floor(LEVEL_HEIGHT / 2);

        makeRoom(centerX, centerY, 0, 13);
        findWallTiles();

        // Render the background first
        renderBackground();

        // Create wall sprites
        wallTiles.forEach((pos) => {
          const [x, y] = pos.split(",").map(Number);
          createWall(x, y);
        });

        placeEntities();
      }

      function createWallSprite(x, y) {
        const wall = game.add.sprite(x * TILE_SIZE, y * TILE_SIZE);
        game.physics.arcade.enable(wall);
        wall.body.immovable = true;
        wall.width = TILE_SIZE;
        wall.height = TILE_SIZE;
        wall.body.moves = false;

        // Check if this is a southern edge wall
        if (isWall(x, y - 1)) {
          // Adjust collision box for southern walls
          wall.body.height = TILE_SIZE / 2;
        }

        wallsGroup.add(wall);
      }

      function placeEntities() {
        if (rooms.length === 0) return;

        // Place enemies
        for (let i = 0; i < ENTITY_CONFIG.NUM_ENEMIES; i++) {
          const room = rooms[Math.floor(Math.random() * rooms.length)];
          const position = getValidPosition(room);
          if (position) {
            new Enemy(game, position.x, position.y);
          }
        }

        // Place chests
        for (let i = 0; i < ENTITY_CONFIG.NUM_CHESTS; i++) {
          const room = rooms[Math.floor(Math.random() * rooms.length)];
          const position = getValidPosition(room);
          if (position) {
            new Chest(game, position.x, position.y);
          }
        }

        // Place player in first room
        const playerRoom = rooms[0];
        const playerPos = getValidPosition(playerRoom);
        if (playerPos) {
          player = new Player(game, playerPos.x, playerPos.y);
        }
      }
    </script>
  </body>
</html>
